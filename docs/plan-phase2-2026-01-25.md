# Phase 2 Plan — CODEX_HOME Resolution + User Input Collection

---
Context & Background

You are working on CodexMonitor, a multi-client UI for driving Codex app-server sessions. The project lives at /Volumes/YouTube 4TB/CodexMonitor.

Architecture:
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│  iOS App    │────▶│   Daemon    │────▶│ codex       │
│  (SwiftUI)  │ TCP │   (Rust)    │     │ app-server  │
└─────────────┘     └─────────────┘     └─────────────┘
                         ▲
┌─────────────┐          │
│ Desktop App │──────────┘
│ (Tauri+React)│
└─────────────┘

We are syncing with upstream (github.com/Dimillian/CodexMonitor) which is 30 commits ahead. Phase 1 (macOS 15 fixes + JSON-RPC string IDs) is complete. This is Phase 2.

---
Task 1: CODEX_HOME Resolution Fix

Why We're Doing This

Currently, resolve_codex_home() returns Option<PathBuf> and callers must add .or_else(resolve_default_codex_home) fallback chains. This is:
- Repetitive (same fallback in 4+ places)
- Error-prone (easy to forget the fallback)
- Inconsistent (some callers might handle None differently)

The fix centralizes the fallback inside resolve_codex_home() itself, so it always returns a valid path.

What to Change

File 1: src-tauri/src/codex_home.rs

Current (around line 22):
```
pub fn resolve_codex_home() -> Option<PathBuf> {
    // ... env var checks ...
    None  // <-- This is the problem
}
```

Change to:
```
pub fn resolve_codex_home() -> Option<PathBuf> {
    // ... env var checks ...
    resolve_default_codex_home()  // <-- Always fall back to ~/.codex
}
```

File 2: src-tauri/src/codex.rs

Find any calls like:
```
resolve_codex_home().or_else(resolve_default_codex_home)
```

Simplify to:
```
resolve_codex_home()
```

File 3: src-tauri/src/bin/codex_monitor_daemon.rs

Same pattern - remove redundant .or_else(resolve_default_codex_home) calls.

File 4: src-tauri/src/prompts.rs

Same pattern - remove redundant fallback chains.

File 5: src-tauri/src/local_usage_core.rs (if it exists)

Check for and remove any redundant fallback patterns.

How to Verify

cd "/Volumes/YouTube 4TB/CodexMonitor"

# 1. Build Rust
cargo build --manifest-path src-tauri/Cargo.toml

# 2. Verify CODEX_HOME resolution works
# Unset env var and confirm it falls back to ~/.codex
CODEX_HOME= cargo test --manifest-path src-tauri/Cargo.toml

# 3. Check no unwrap panics on None
grep -r "resolve_codex_home().unwrap()" src-tauri/src/
# Should return nothing (no unsafe unwraps)

---
Task 2: User Input Collection Feature

Why We're Doing This

Currently, when a Codex agent needs user input (e.g., "Which database should I use?"), it has no way to prompt the user interactively. The agent just guesses or fails.

This feature adds:
- A new event type item/tool/requestUserInput that agents can emit
- UI components to display the question and collect answers
- Response mechanism using existing respond_to_server_request

This is critical for iOS - it means agents can ask questions while you're out delivering.

New TypeScript Types

Add to src/types.ts:

```ts
// User Input Collection Types
export type RequestUserInputOption = {
  label: string;
  description: string;
};

export type RequestUserInputQuestion = {
  id: string;
  header: string;
  question: string;
  options?: RequestUserInputOption[];
};

export type RequestUserInputParams = {
  thread_id: string;
  turn_id: string;
  item_id: string;
  questions: RequestUserInputQuestion[];
};

export type RequestUserInputRequest = {
  workspace_id: string;
  request_id: number | string;
  params: RequestUserInputParams;
};

export type RequestUserInputAnswer = {
  answers: string[];
};

export type RequestUserInputResponse = {
  answers: Record<string, RequestUserInputAnswer>;
};
```

New Files to Create

File 1: src/features/app/components/RequestUserInputMessage.tsx

```tsx
import { useState } from "react";
import { RequestUserInputRequest, RequestUserInputResponse } from "../../../types";
import { respondToServerRequest } from "../../../services/tauri";
import "./request-user-input.css";

interface Props {
  request: RequestUserInputRequest;
  onComplete: () => void;
}

export function RequestUserInputMessage({ request, onComplete }: Props) {
  const [answers, setAnswers] = useState<Record<string, string[]>>({});
  const [submitting, setSubmitting] = useState(false);

  const handleOptionSelect = (questionId: string, option: string) => {
    setAnswers(prev => ({
      ...prev,
      [questionId]: [option]
    }));
  };

  const handleTextInput = (questionId: string, value: string) => {
    setAnswers(prev => ({
      ...prev,
      [questionId]: [value]
    }));
  };

  const handleSubmit = async () => {
    setSubmitting(true);
    try {
      const response: RequestUserInputResponse = {
        answers: Object.fromEntries(
          Object.entries(answers).map(([id, ans]) => [id, { answers: ans }])
        )
      };
      await respondToServerRequest(
        request.workspace_id,
        request.request_id,
        response
      );
      onComplete();
    } catch (error) {
      console.error("Failed to submit user input:", error);
    } finally {
      setSubmitting(false);
    }
  };

  const allQuestionsAnswered = request.params.questions.every(
    q => answers[q.id]?.length > 0
  );

  return (
    <div className="request-user-input">
      <div className="request-user-input-header">
        <span className="request-user-input-icon">❓</span>
        <span>Agent needs your input</span>
      </div>

      {request.params.questions.map(question => (
        <div key={question.id} className="request-user-input-question">
          <div className="question-header">{question.header}</div>
          <div className="question-text">{question.question}</div>

          {question.options ? (
            <div className="question-options">
              {question.options.map(option => (
                <button
                  key={option.label}
                  className={`option-button ${
                    answers[question.id]?.[0] === option.label ? "selected" : ""
                  }`}
                  onClick={() => handleOptionSelect(question.id, option.label)}
                >
                  <span className="option-label">{option.label}</span>
                  <span className="option-description">{option.description}</span>
                </button>
              ))}
            </div>
          ) : (
            <input
              type="text"
              className="question-input"
              placeholder="Type your answer..."
              value={answers[question.id]?.[0] || ""}
              onChange={e => handleTextInput(question.id, e.target.value)}
            />
          )}
        </div>
      ))}

      <button
        className="submit-button"
        disabled={!allQuestionsAnswered || submitting}
        onClick={handleSubmit}
      >
        {submitting ? "Submitting..." : "Submit Answers"}
      </button>
    </div>
  );
}
```

File 2: src/styles/request-user-input.css

```css
.request-user-input {
  background: var(--color-surface);
  border: 1px solid var(--color-border);
  border-radius: 8px;
  padding: 16px;
  margin: 8px 0;
}

.request-user-input-header {
  display: flex;
  align-items: center;
  gap: 8px;
  font-weight: 600;
  margin-bottom: 16px;
  color: var(--color-warning);
}

.request-user-input-icon {
  font-size: 1.2em;
}

.request-user-input-question {
  margin-bottom: 16px;
  padding-bottom: 16px;
  border-bottom: 1px solid var(--color-border);
}

.request-user-input-question:last-of-type {
  border-bottom: none;
}

.question-header {
  font-size: 0.85em;
  color: var(--color-text-secondary);
  margin-bottom: 4px;
}

.question-text {
  font-weight: 500;
  margin-bottom: 12px;
}

.question-options {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.option-button {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  padding: 12px;
  background: var(--color-background);
  border: 1px solid var(--color-border);
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.15s ease;
  text-align: left;
}

.option-button:hover {
  border-color: var(--color-primary);
}

.option-button.selected {
  border-color: var(--color-primary);
  background: var(--color-primary-subtle);
}

.option-label {
  font-weight: 500;
}

.option-description {
  font-size: 0.85em;
  color: var(--color-text-secondary);
  margin-top: 4px;
}

.question-input {
  width: 100%;
  padding: 10px 12px;
  background: var(--color-background);
  border: 1px solid var(--color-border);
  border-radius: 6px;
  color: var(--color-text);
  font-size: 1em;
}

.question-input:focus {
  outline: none;
  border-color: var(--color-primary);
}

.submit-button {
  width: 100%;
  padding: 12px;
  background: var(--color-primary);
  color: white;
  border: none;
  border-radius: 6px;
  font-weight: 600;
  cursor: pointer;
  transition: opacity 0.15s ease;
}

.submit-button:hover:not(:disabled) {
  opacity: 0.9;
}

.submit-button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}
```

File 3: src/features/threads/hooks/useThreadUserInput.ts

```ts
import { useState, useCallback } from "react";
import { RequestUserInputRequest } from "../../../types";

export function useThreadUserInput() {
  const [pendingRequests, setPendingRequests] = useState<RequestUserInputRequest[]>([]);

  const addRequest = useCallback((request: RequestUserInputRequest) => {
    setPendingRequests(prev => [...prev, request]);
  }, []);

  const removeRequest = useCallback((requestId: number | string) => {
    setPendingRequests(prev =>
      prev.filter(r => r.request_id !== requestId)
    );
  }, []);

  return {
    pendingRequests,
    addRequest,
    removeRequest
  };
}
```

File 4: src/features/threads/hooks/useThreadUserInputEvents.ts

```ts
import { useEffect } from "react";
import { listen } from "@tauri-apps/api/event";
import { RequestUserInputRequest } from "../../../types";

export function useThreadUserInputEvents(
  onRequest: (request: RequestUserInputRequest) => void
) {
  useEffect(() => {
    const unlisten = listen<RequestUserInputRequest>(
      "item/tool/requestUserInput",
      (event) => {
        onRequest(event.payload);
      }
    );

    return () => {
      unlisten.then(fn => fn());
    };
  }, [onRequest]);
}
```

Modifications to Existing Files

File: src/features/app/hooks/useAppServerEvents.ts

Add the new event type to the event listener setup. Look for where other item/tool/* events are handled and add:

```ts
// Add import
import { RequestUserInputRequest } from "../../../types";

// In the event handling section, add:
case "item/tool/requestUserInput":
  // Emit to thread-specific handler
  emit("item/tool/requestUserInput", payload as RequestUserInputRequest);
  break;
```

File: src/styles/index.css (or main CSS entry point)

Add import:
```
@import "./request-user-input.css";
```

How to Verify

cd "/Volumes/YouTube 4TB/CodexMonitor"

# 1. TypeScript compilation
npm run build

# 2. Check for type errors
npx tsc --noEmit

# 3. Rust build (shouldn't need changes but verify)
cargo build --manifest-path src-tauri/Cargo.toml

# 4. Full Tauri build
npm run tauri build -- --debug

# 5. Manual test: Launch app, start a Codex session, and trigger
#    a scenario where the agent would ask for user input
#    (e.g., ambiguous task that needs clarification)

---
Documentation Updates

Update docs/CHANGELOG.md or create if doesn't exist:

```
## [Unreleased] - 2025-01-25

### Fixed
- CODEX_HOME resolution now consistently falls back to ~/.codex
- Removed redundant fallback chains in codex.rs, daemon.rs, prompts.rs

### Added
- User Input Collection: Agents can now prompt users for input
  - New event: `item/tool/requestUserInput`
  - New UI component: RequestUserInputMessage
  - Supports both multiple-choice and free-text questions
```

---
Git Workflow

After all changes compile and tests pass:

cd "/Volumes/YouTube 4TB/CodexMonitor"

# 1. Check what changed
git status
git diff

# 2. Stage changes
git add src-tauri/src/codex_home.rs
git add src-tauri/src/codex.rs
git add src-tauri/src/bin/codex_monitor_daemon.rs
git add src-tauri/src/prompts.rs
git add src/types.ts
git add src/features/app/components/RequestUserInputMessage.tsx
git add src/features/threads/hooks/useThreadUserInput.ts
git add src/features/threads/hooks/useThreadUserInputEvents.ts
git add src/styles/request-user-input.css
git add src/features/app/hooks/useAppServerEvents.ts
git add docs/CHANGELOG.md

# 3. Commit with descriptive message
git commit -m "feat: add CODEX_HOME fix and User Input Collection

- Centralize CODEX_HOME fallback in resolve_codex_home()
- Remove redundant .or_else() chains across codebase
- Add RequestUserInputMessage component for agent prompts
- Add useThreadUserInput and useThreadUserInputEvents hooks
- Support both multiple-choice and text input questions
- Use existing respond_to_server_request for responses

Synced from upstream Dimillian/CodexMonitor"

# 4. Push to your fork
git push origin main

---
Success Criteria

- cargo build passes with no errors
- npm run build passes with no errors
- No TypeScript type errors (npx tsc --noEmit)
- CODEX_HOME resolves to ~/.codex when env var is unset
- RequestUserInputMessage component renders without crashes
- Answering questions and clicking Submit calls respondToServerRequest
- All changes committed and pushed

---
Do NOT:
- Change the existing default_access_mode in types.rs (it's a local customization)
- Modify base.css color scheme (local customization)
- Add new dependencies unless absolutely necessary
